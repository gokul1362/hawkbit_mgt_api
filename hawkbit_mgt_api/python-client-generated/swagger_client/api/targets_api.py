# coding: utf-8

"""
    hawkBit REST APIs

    Eclipse hawkBitâ„¢ is a domain-independent back-end framework for rolling out software updates to constrained edge devices as well as more powerful controllers and gateways connected to IP based networking infrastructure.   # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class TargetsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activate_auto_confirm(self, target_id, **kwargs):  # noqa: E501
        """Activate auto-confirm on a specific target  # noqa: E501

        Handles the POST request to activate auto-confirmation for a specific target. As a result all current active as well as future actions will automatically be confirmed by mentioning the initiator as triggered person. Actions will be automatically confirmed, as long as auto-confirmation is active. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_auto_confirm(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param MgmtTargetAutoConfirmUpdate body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.activate_auto_confirm_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.activate_auto_confirm_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def activate_auto_confirm_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Activate auto-confirm on a specific target  # noqa: E501

        Handles the POST request to activate auto-confirmation for a specific target. As a result all current active as well as future actions will automatically be confirmed by mentioning the initiator as triggered person. Actions will be automatically confirmed, as long as auto-confirmation is active. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_auto_confirm_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param MgmtTargetAutoConfirmUpdate body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_auto_confirm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `activate_auto_confirm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/autoConfirm/activate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def assign_target_type(self, body, target_id, **kwargs):  # noqa: E501
        """Assign target type to a target  # noqa: E501

        Assign or update the target type of a target. Required permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_target_type(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtId body: (required)
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_target_type_with_http_info(body, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_target_type_with_http_info(body, target_id, **kwargs)  # noqa: E501
            return data

    def assign_target_type_with_http_info(self, body, target_id, **kwargs):  # noqa: E501
        """Assign target type to a target  # noqa: E501

        Assign or update the target type of a target. Required permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_target_type_with_http_info(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtId body: (required)
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_target_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `assign_target_type`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `assign_target_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/targettype', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_action(self, target_id, action_id, **kwargs):  # noqa: E501
        """Cancel action for a specific target  # noqa: E501

        Cancels an active action, only active actions can be deleted. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_action(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :param bool force:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_action_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_action_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
            return data

    def cancel_action_with_http_info(self, target_id, action_id, **kwargs):  # noqa: E501
        """Cancel action for a specific target  # noqa: E501

        Cancels an active action, only active actions can be deleted. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_action_with_http_info(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :param bool force:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'action_id', 'force']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `cancel_action`")  # noqa: E501
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params or
                params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `cancel_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']  # noqa: E501

        query_params = []
        if 'force' in params:
            query_params.append(('force', params['force']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/actions/{actionId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_metadata(self, body, target_id, **kwargs):  # noqa: E501
        """Create a list of meta data for a specific target  # noqa: E501

        Create a list of meta data entries Required permissions: READ_REPOSITORY and UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_metadata(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtMetadata] body: (required)
        :param str target_id: (required)
        :return: list[MgmtMetadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_metadata_with_http_info(body, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_metadata_with_http_info(body, target_id, **kwargs)  # noqa: E501
            return data

    def create_metadata_with_http_info(self, body, target_id, **kwargs):  # noqa: E501
        """Create a list of meta data for a specific target  # noqa: E501

        Create a list of meta data entries Required permissions: READ_REPOSITORY and UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_metadata_with_http_info(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtMetadata] body: (required)
        :param str target_id: (required)
        :return: list[MgmtMetadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_metadata`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `create_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MgmtMetadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_targets(self, body, **kwargs):  # noqa: E501
        """Create target(s)  # noqa: E501

        Handles the POST request of creating new targets. The request body must always be a list of targets. Required Permission: CREATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_targets(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtTargetRequestBody] body: (required)
        :return: list[MgmtTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_targets_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_targets_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_targets_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create target(s)  # noqa: E501

        Handles the POST request of creating new targets. The request body must always be a list of targets. Required Permission: CREATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_targets_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtTargetRequestBody] body: (required)
        :return: list[MgmtTarget]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_targets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_targets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MgmtTarget]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deactivate_auto_confirm(self, target_id, **kwargs):  # noqa: E501
        """Deactivate auto-confirm on a specific target  # noqa: E501

        Handles the POST request to deactivate auto-confirmation for a specific target. All active actions will remain unchanged while all future actions need to be confirmed, before processing with the deployment. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deactivate_auto_confirm(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.deactivate_auto_confirm_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.deactivate_auto_confirm_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def deactivate_auto_confirm_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Deactivate auto-confirm on a specific target  # noqa: E501

        Handles the POST request to deactivate auto-confirmation for a specific target. All active actions will remain unchanged while all future actions need to be confirmed, before processing with the deployment. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deactivate_auto_confirm_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deactivate_auto_confirm" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `deactivate_auto_confirm`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/autoConfirm/deactivate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_metadata(self, target_id, metadata_key, **kwargs):  # noqa: E501
        """Deletes a single meta data entry from a target  # noqa: E501

        Delete a single meta data. Required permission: UPDATE_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_metadata(target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_metadata_with_http_info(target_id, metadata_key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_metadata_with_http_info(target_id, metadata_key, **kwargs)  # noqa: E501
            return data

    def delete_metadata_with_http_info(self, target_id, metadata_key, **kwargs):  # noqa: E501
        """Deletes a single meta data entry from a target  # noqa: E501

        Delete a single meta data. Required permission: UPDATE_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_metadata_with_http_info(target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'metadata_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `delete_metadata`")  # noqa: E501
        # verify the required parameter 'metadata_key' is set
        if ('metadata_key' not in params or
                params['metadata_key'] is None):
            raise ValueError("Missing the required parameter `metadata_key` when calling `delete_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'metadata_key' in params:
            path_params['metadataKey'] = params['metadata_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/metadata/{metadataKey}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_target(self, target_id, **kwargs):  # noqa: E501
        """Delete target by id  # noqa: E501

        Handles the DELETE request of deleting a single target. Required Permission: DELETE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_target(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_target_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_target_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def delete_target_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Delete target by id  # noqa: E501

        Handles the DELETE request of deleting a single target. Required Permission: DELETE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_target_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_target" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `delete_target`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_action(self, target_id, action_id, **kwargs):  # noqa: E501
        """Return action by id of a specific target  # noqa: E501

        Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :return: MgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_action_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_action_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
            return data

    def get_action_with_http_info(self, target_id, action_id, **kwargs):  # noqa: E501
        """Return action by id of a specific target  # noqa: E501

        Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action_with_http_info(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :return: MgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'action_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_action`")  # noqa: E501
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params or
                params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `get_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/actions/{actionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_action_history(self, target_id, **kwargs):  # noqa: E501
        """Return actions for a specific target  # noqa: E501

        Handles the GET request of retrieving the full action history of a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action_history(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_action_history_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_action_history_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_action_history_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return actions for a specific target  # noqa: E501

        Handles the GET request of retrieving the full action history of a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action_history_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'offset', 'limit', 'sort', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action_history" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_action_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/actions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedListMgmtAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_action_status_list(self, target_id, action_id, **kwargs):  # noqa: E501
        """Return status of a specific action on a specific target  # noqa: E501

        Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action_status_list(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :param int offset:
        :param int limit:
        :param str sort:
        :return: PagedListMgmtActionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_action_status_list_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_action_status_list_with_http_info(target_id, action_id, **kwargs)  # noqa: E501
            return data

    def get_action_status_list_with_http_info(self, target_id, action_id, **kwargs):  # noqa: E501
        """Return status of a specific action on a specific target  # noqa: E501

        Handles the GET request of retrieving a specific action on a specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_action_status_list_with_http_info(target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param int action_id: (required)
        :param int offset:
        :param int limit:
        :param str sort:
        :return: PagedListMgmtActionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'action_id', 'offset', 'limit', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_action_status_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_action_status_list`")  # noqa: E501
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params or
                params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `get_action_status_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/actions/{actionId}/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedListMgmtActionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_assigned_distribution_set(self, target_id, **kwargs):  # noqa: E501
        """Return the assigned distribution set of a specific target  # noqa: E501

        Handles the GET request of retrieving the assigned distribution set of an specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assigned_distribution_set(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtDistributionSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_assigned_distribution_set_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_assigned_distribution_set_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_assigned_distribution_set_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return the assigned distribution set of a specific target  # noqa: E501

        Handles the GET request of retrieving the assigned distribution set of an specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assigned_distribution_set_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtDistributionSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_assigned_distribution_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_assigned_distribution_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/assignedDS', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtDistributionSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attributes(self, target_id, **kwargs):  # noqa: E501
        """Return attributes of a specific target  # noqa: E501

        Handles the GET request of retrieving the attributes of a specific target. Reponse is a key/value list. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTargetAttributes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_attributes_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_attributes_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_attributes_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return attributes of a specific target  # noqa: E501

        Handles the GET request of retrieving the attributes of a specific target. Reponse is a key/value list. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTargetAttributes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/attributes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtTargetAttributes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_auto_confirm_status(self, target_id, **kwargs):  # noqa: E501
        """Return the current auto-confitm state for a specific target  # noqa: E501

        Handles the GET request to check the current auto-confirmation state of a target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auto_confirm_status(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTargetAutoConfirm
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_auto_confirm_status_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_auto_confirm_status_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_auto_confirm_status_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return the current auto-confitm state for a specific target  # noqa: E501

        Handles the GET request to check the current auto-confirmation state of a target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auto_confirm_status_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTargetAutoConfirm
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_auto_confirm_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_auto_confirm_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/autoConfirm', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtTargetAutoConfirm',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_installed_distribution_set(self, target_id, **kwargs):  # noqa: E501
        """Return installed distribution set of a specific target  # noqa: E501

        Handles the GET request of retrieving the installed distribution set of an specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_installed_distribution_set(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtDistributionSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_installed_distribution_set_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_installed_distribution_set_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_installed_distribution_set_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return installed distribution set of a specific target  # noqa: E501

        Handles the GET request of retrieving the installed distribution set of an specific target. Required Permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_installed_distribution_set_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtDistributionSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_installed_distribution_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_installed_distribution_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/installedDS', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtDistributionSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metadata(self, target_id, **kwargs):  # noqa: E501
        """Return metadata for specific target  # noqa: E501

        Get a paged list of meta data for a target. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metadata_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_metadata_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_metadata_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return metadata for specific target  # noqa: E501

        Get a paged list of meta data for a target. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'offset', 'limit', 'sort', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedListMgmtMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_metadata_value(self, target_id, metadata_key, **kwargs):  # noqa: E501
        """Return single metadata value for a specific key of a target  # noqa: E501

        Get a single meta data value for a meta data key. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata_value(target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: MgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_metadata_value_with_http_info(target_id, metadata_key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_metadata_value_with_http_info(target_id, metadata_key, **kwargs)  # noqa: E501
            return data

    def get_metadata_value_with_http_info(self, target_id, metadata_key, **kwargs):  # noqa: E501
        """Return single metadata value for a specific key of a target  # noqa: E501

        Get a single meta data value for a meta data key. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_metadata_value_with_http_info(target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: MgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id', 'metadata_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_metadata_value" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_metadata_value`")  # noqa: E501
        # verify the required parameter 'metadata_key' is set
        if ('metadata_key' not in params or
                params['metadata_key'] is None):
            raise ValueError("Missing the required parameter `metadata_key` when calling `get_metadata_value`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'metadata_key' in params:
            path_params['metadataKey'] = params['metadata_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/metadata/{metadataKey}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags(self, target_id, **kwargs):  # noqa: E501
        """Return tags for specific target  # noqa: E501

        Get a paged list of tags for a target. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: list[MgmtTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tags_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tags_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_tags_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return tags for specific target  # noqa: E501

        Get a paged list of tags for a target. Required permission: READ_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: list[MgmtTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_tags`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MgmtTag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_target(self, target_id, **kwargs):  # noqa: E501
        """Return target by id  # noqa: E501

        Handles the GET request of retrieving a single target. Required Permission: READ_TARGET.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_target(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_target_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_target_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def get_target_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Return target by id  # noqa: E501

        Handles the GET request of retrieving a single target. Required Permission: READ_TARGET.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_target_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: MgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_target" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `get_target`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtTarget',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_targets(self, **kwargs):  # noqa: E501
        """Return all targets  # noqa: E501

        Handles the GET request of retrieving all targets. Required permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_targets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_targets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_targets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_targets_with_http_info(self, **kwargs):  # noqa: E501
        """Return all targets  # noqa: E501

        Handles the GET request of retrieving all targets. Required permission: READ_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_targets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str offset: The paging offset (default is 0)
        :param str limit: The maximum number of entries in a page (default is 50)
        :param str sort: The query parameter sort allows to define the sort order for the result of a query. A sort criteria consists of the name of a field and the sort direction (ASC for ascending and DESC descending). The sequence of the sort criteria (multiple can be used) defines the sort order of the entities in the result.
        :param str q: Query fields based on the Feed Item Query Language (FIQL). See Entity Definitions for available fields.
        :return: PagedListMgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['offset', 'limit', 'sort', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_targets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedListMgmtTarget',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_assigned_distribution_set(self, body, target_id, **kwargs):  # noqa: E501
        """Assigns a distribution set to a specific target  # noqa: E501

        Handles the POST request for assigning a distribution set to a specific target. Required Permission: READ_REPOSITORY and UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_assigned_distribution_set(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtDistributionSetAssignment] body: (required)
        :param str target_id: (required)
        :param str offline: Offline update (set param to true) that is only reported but not managed by the service, e.g. defaults set in factory, manual updates or migrations from other update systems. A completed action is added to the history of the target(s). Target is set to IN_SYNC state as both assigned and installed DS are set. Note: only executed if the target has currently no running update
        :return: MgmtTargetAssignmentResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_assigned_distribution_set_with_http_info(body, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_assigned_distribution_set_with_http_info(body, target_id, **kwargs)  # noqa: E501
            return data

    def post_assigned_distribution_set_with_http_info(self, body, target_id, **kwargs):  # noqa: E501
        """Assigns a distribution set to a specific target  # noqa: E501

        Handles the POST request for assigning a distribution set to a specific target. Required Permission: READ_REPOSITORY and UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_assigned_distribution_set_with_http_info(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[MgmtDistributionSetAssignment] body: (required)
        :param str target_id: (required)
        :param str offline: Offline update (set param to true) that is only reported but not managed by the service, e.g. defaults set in factory, manual updates or migrations from other update systems. A completed action is added to the history of the target(s). Target is set to IN_SYNC state as both assigned and installed DS are set. Note: only executed if the target has currently no running update
        :return: MgmtTargetAssignmentResponseBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id', 'offline']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_assigned_distribution_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_assigned_distribution_set`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `post_assigned_distribution_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []
        if 'offline' in params:
            query_params.append(('offline', params['offline']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/assignedDS', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtTargetAssignmentResponseBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unassign_target_type(self, target_id, **kwargs):  # noqa: E501
        """Unassign target type from target.  # noqa: E501

        Remove the target type from a target. The target type will be set to null. Required permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unassign_target_type(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unassign_target_type_with_http_info(target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unassign_target_type_with_http_info(target_id, **kwargs)  # noqa: E501
            return data

    def unassign_target_type_with_http_info(self, target_id, **kwargs):  # noqa: E501
        """Unassign target type from target.  # noqa: E501

        Remove the target type from a target. The target type will be set to null. Required permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unassign_target_type_with_http_info(target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str target_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unassign_target_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `unassign_target_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/targettype', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_action(self, body, target_id, action_id, **kwargs):  # noqa: E501
        """Switch an action from soft to forced  # noqa: E501

        Handles the PUT request to switch an action from soft to forced. Required Permission: UPDATE_TARGET.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_action(body, target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtActionRequestBodyPut body: (required)
        :param str target_id: (required)
        :param int action_id: (required)
        :return: MgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_action_with_http_info(body, target_id, action_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_action_with_http_info(body, target_id, action_id, **kwargs)  # noqa: E501
            return data

    def update_action_with_http_info(self, body, target_id, action_id, **kwargs):  # noqa: E501
        """Switch an action from soft to forced  # noqa: E501

        Handles the PUT request to switch an action from soft to forced. Required Permission: UPDATE_TARGET.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_action_with_http_info(body, target_id, action_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtActionRequestBodyPut body: (required)
        :param str target_id: (required)
        :param int action_id: (required)
        :return: MgmtAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id', 'action_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_action" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_action`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `update_action`")  # noqa: E501
        # verify the required parameter 'action_id' is set
        if ('action_id' not in params or
                params['action_id'] is None):
            raise ValueError("Missing the required parameter `action_id` when calling `update_action`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'action_id' in params:
            path_params['actionId'] = params['action_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/actions/{actionId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_metadata(self, body, target_id, metadata_key, **kwargs):  # noqa: E501
        """Updates a single meta data value of a target  # noqa: E501

        Update a single meta data value for speficic key. Required permission: UPDATE_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_metadata(body, target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtMetadataBodyPut body: (required)
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: MgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_metadata_with_http_info(body, target_id, metadata_key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_metadata_with_http_info(body, target_id, metadata_key, **kwargs)  # noqa: E501
            return data

    def update_metadata_with_http_info(self, body, target_id, metadata_key, **kwargs):  # noqa: E501
        """Updates a single meta data value of a target  # noqa: E501

        Update a single meta data value for speficic key. Required permission: UPDATE_REPOSITORY  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_metadata_with_http_info(body, target_id, metadata_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtMetadataBodyPut body: (required)
        :param str target_id: (required)
        :param str metadata_key: (required)
        :return: MgmtMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id', 'metadata_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_metadata`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `update_metadata`")  # noqa: E501
        # verify the required parameter 'metadata_key' is set
        if ('metadata_key' not in params or
                params['metadata_key'] is None):
            raise ValueError("Missing the required parameter `metadata_key` when calling `update_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501
        if 'metadata_key' in params:
            path_params['metadataKey'] = params['metadata_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}/metadata/{metadataKey}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_target(self, body, target_id, **kwargs):  # noqa: E501
        """Update target by id  # noqa: E501

        Handles the PUT request of updating a target. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_target(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtTargetRequestBody body: (required)
        :param str target_id: (required)
        :return: MgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_target_with_http_info(body, target_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_target_with_http_info(body, target_id, **kwargs)  # noqa: E501
            return data

    def update_target_with_http_info(self, body, target_id, **kwargs):  # noqa: E501
        """Update target by id  # noqa: E501

        Handles the PUT request of updating a target. Required Permission: UPDATE_TARGET  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_target_with_http_info(body, target_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MgmtTargetRequestBody body: (required)
        :param str target_id: (required)
        :return: MgmtTarget
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'target_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_target" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_target`")  # noqa: E501
        # verify the required parameter 'target_id' is set
        if ('target_id' not in params or
                params['target_id'] is None):
            raise ValueError("Missing the required parameter `target_id` when calling `update_target`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'target_id' in params:
            path_params['targetId'] = params['target_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/hal+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/hal+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/rest/v1/targets/{targetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MgmtTarget',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
